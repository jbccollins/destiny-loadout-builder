import { EFragmentId } from '@dlb/generated/fragment/EFragmentId';
import {
	formatStringForFile,
	getSerializableValue,
	getSerializedBonusStats,
} from '@dlb/scripts/generation/utils';
import { IFragment } from '@dlb/types/generation';
import { EElementId } from '@dlb/types/IdEnums';

export const generateFragmentMapping = (fragments: IFragment[]): string => {
	const enumsToSerialize = {
		id: { enumDefinition: EFragmentId, enumName: 'EFragmentId' },
		elementId: { enumDefinition: EElementId, enumName: 'EElementId' },
	};

	const serializeFragments: Record<string, unknown>[] = [];
	fragments.forEach((fragment) => {
		const serializedFragment = { ...fragment } as Record<string, unknown>;
		Object.keys(enumsToSerialize).forEach((key) => {
			const serializedResult = getSerializableValue(
				fragment[key],
				enumsToSerialize[key].enumDefinition,
				enumsToSerialize[key].enumName
			);
			serializedFragment[key] = serializedResult;
		});
		const serialzedBonusStats = getSerializedBonusStats(fragment);
		fragment.bonuses.forEach((_, i) => {
			serializedFragment.bonuses[i].stat = serialzedBonusStats[i];
		});
		serializeFragments.push(serializedFragment);
	});

	const fragmentIdToFragmentMappingString = serializeFragments.map(
		(fragment) => `[${fragment.id}]: ${JSON.stringify(fragment, null, 2)},`
	);

	const setDataFileSource = `// This file is generated by the generateFragmentMapping.ts script.
	// Do not manually make changes to this file.

	import { EnumDictionary } from "@dlb/types/globals";
	import { IFragment } from "@dlb/types/generation";
  import { EFragmentId } from "@dlb/generated/fragment/EFragmentId";
	import { EArmorStatId, EElementId } from "@dlb/types/IdEnums";

	export const FragmentIdToFragmentMapping: EnumDictionary<EFragmentId, IFragment> = {
		${fragmentIdToFragmentMappingString.join(' ')}
	}
	`;
	return formatStringForFile(setDataFileSource);
};
